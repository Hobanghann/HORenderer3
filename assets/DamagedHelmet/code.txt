#include "renderer.h"

#include <iostream>

#include "core/io/resource_loader.h"
#include "core/math/frustum.h"
#include "resource/material.h"
#include "resource/mesh.h"
#include "resource/skeleton.h"
#include "resource/skin.h"
#include "shaders/pbr_fs.h"
#include "shaders/pbr_vs.h"
#include "virtual_gpu/virtual_gpu.h"

namespace ho {
    bool Renderer::Initialize(uint8_t* color_buffer, int width, int height) {
        if (color_buffer == nullptr || width <= 0 || height <= 0) {
            return false;
        }
        // Initialize GPU
        VirtualGPU::GetInstance().Initialize(color_buffer, width, height, VG_BGRA, VG_UNSIGNED_BYTE);

        // Set GPU state
        vgClearColor(0.9f, 0.9f, 0.9f, 1.f);
        vgDepthFunc(VG_LESS);
        vgPolygonMode(VG_FRONT_AND_BACK, VG_FILL);
        vgEnable(VG_CULL_FACE);
        vgEnable(VG_DEPTH_TEST);

        // Set Camera
        camera.modeling_transform =
            Transform3D(Basis3D(-Vector3::UNIT_X, Vector3::UNIT_Y, -Vector3::UNIT_Z), Vector3(0.f, 3.f, 10.f))
                .LookedAt(Vector3::ZERO, Vector3::UNIT_Y);
        camera.projection = Projection(math::PI / 2.f, (real)width / (real)height, 1.01f, 500.f);

        // Set Object
        real scale = 5.0_r;
        object.modeling_transform = Transform3D(
            Basis3D(scale * Vector3::UNIT_X, scale * Vector3::UNIT_Y, scale * Vector3::UNIT_Z), Vector3(0.f, 0.f, 0.f));

        // Load Resource for object
        ResourceLoader::Model model =
            ResourceLoader::LoadModel(Path(std::string("DamagedHelmet/glTF/DamagedHelmet.gltf")), resource_manager_);

        // upload mesh to gpu
        const Mesh* mesh = resource_manager_.GetMesh(model.mesh);
        if (!mesh) {
            return false;
        }

        std::vector<VGuint> vao;
        vao.resize(mesh->GetSubMeshCount());
        vgGenVertexArrays(mesh->GetSubMeshCount(), vao.data());

        std::vector<VGuint> vbo;
        vbo.resize(mesh->GetSubMeshCount());
        vgGenBuffers(mesh->GetSubMeshCount(), vbo.data());

        std::vector<VGuint> ebo;
        ebo.resize(mesh->GetSubMeshCount());
        vgGenBuffers(mesh->GetSubMeshCount(), ebo.data());

        for (uint32_t smi = 0; smi < mesh->GetSubMeshCount(); smi++) {
            const Mesh::SubMesh& sub_mesh = mesh->sub_meshes[smi];

            vgBindVertexArray(vao[smi]);

            vgBindBuffer(VG_ARRAY_BUFFER, vbo[smi]);

            // make interleaved vertex buffer
            // | Position | normal | tangent | uv0 |
            std::vector<float> buf;
            buf.reserve(sub_mesh.positions.size() * sizeof(float) * 12);
            for (int vi = 0; vi < sub_mesh.positions.size(); vi++) {
                buf.push_back(sub_mesh.positions[vi].x);
                buf.push_back(sub_mesh.positions[vi].y);
                buf.push_back(sub_mesh.positions[vi].z);
                if (sub_mesh.normals.empty()) {
                    buf.push_back(0.f);
                    buf.push_back(0.f);
                    buf.push_back(0.f);
                } else {
                    buf.push_back(sub_mesh.normals[vi].x);
                    buf.push_back(sub_mesh.normals[vi].y);
                    buf.push_back(sub_mesh.normals[vi].z);
                }
                if (sub_mesh.tangents.empty()) {
                    buf.push_back(0.f);
                    buf.push_back(0.f);
                    buf.push_back(0.f);
                    buf.push_back(0.f);
                } else {
                    buf.push_back(sub_mesh.tangents[vi].x);
                    buf.push_back(sub_mesh.tangents[vi].y);
                    buf.push_back(sub_mesh.tangents[vi].z);
                    buf.push_back(sub_mesh.tangents[vi].w);
                }
                buf.push_back(sub_mesh.uvs[vi][0].x);
                buf.push_back(sub_mesh.uvs[vi][0].y);
            }

            // upload interleaved vertex buffer
            vgBufferData(VG_ARRAY_BUFFER, sizeof(float) * buf.size(), buf.data(), VG_STATIC_DRAW);

            vgEnableVertexAttribArray(0);  // position
            vgVertexAttribPointer(0, 3, VG_FLOAT, false, sizeof(float) * 12, 0);
            vgEnableVertexAttribArray(1);  // normal
            vgVertexAttribPointer(1, 3, VG_FLOAT, false, sizeof(float) * 12, (const void*)(sizeof(float) * 3));
            vgEnableVertexAttribArray(2);  // tangent
            vgVertexAttribPointer(2, 4, VG_FLOAT, false, sizeof(float) * 12, (const void*)(sizeof(float) * 6));
            vgEnableVertexAttribArray(3);  // uv0
            vgVertexAttribPointer(3, 2, VG_FLOAT, false, sizeof(float) * 12, (const void*)(sizeof(float) * 10));

            vgBindBuffer(VG_ELEMENT_ARRAY_BUFFER, ebo[smi]);
            vgBufferData(VG_ELEMENT_ARRAY_BUFFER, sizeof(uint32_t) * sub_mesh.indices.size(), sub_mesh.indices.data(),
                         VG_STATIC_DRAW);

            vgBindVertexArray(0);
            vgBindBuffer(VG_ARRAY_BUFFER, 0);
            vgBindBuffer(VG_ELEMENT_ARRAY_BUFFER, 0);

            UploadedSubMesh usm;
            usm.vao = vao[smi];
            usm.vbo = vbo[smi];
            usm.ebo = ebo[smi];
            usm.index_count = (uint32_t)sub_mesh.indices.size();
            const Material* material = resource_manager_.GetMaterial(sub_mesh.material);
            if (!material) {
                return false;
            }
            usm.material = material;
            usm.sphere = sub_mesh.sphere;
            usm.aabb = sub_mesh.aabb;
            object.sub_meshes.push_back(usm);
        }

        object.sphere = mesh->sphere;
        object.aabb = mesh->aabb;

        // delete mesh after updloading
        resource_manager_.DeleteMesh(model.mesh);

        // upload textures to gpu
        vgActiveTexture(VG_TEXTURE0);

        for (int i = 0; i < model.materials.size(); i++) {
            const Material* material = resource_manager_.GetMaterial(model.materials[i]);
            if (!material) {
                return false;
            }
            for (ResourceID rid : material->textures) {
                const Texture* tex = resource_manager_.GetTexture(rid);
                if (tex) {
                    auto it = object.texture_rid_to_vgid.find(rid);
                    if (it == object.texture_rid_to_vgid.end()) {
                        VGuint tid;
                        vgGenTextures(1, &tid);
                        object.texture_rid_to_vgid.insert({rid, tid});

                        VGenum format;
                        switch (tex->images[0]->format()) {
                            case Image::IMAGE_FORMAT_R8:
                                format = VG_RED;
                                break;
                            case Image::IMAGE_FORMAT_RG8:
                                format = VG_RG;
                                break;
                            case Image::IMAGE_FORMAT_RGB8:
                                format = VG_RGB;
                                break;
                            case Image::IMAGE_FORMAT_RGBA8:
                                format = VG_RGBA;
                                break;
                            default:
                                format = VG_RGBA;
                        }
                        vgBindTexture(VG_TEXTURE_2D, tid);
                        vgTexImage2D(VG_TEXTURE_2D, 0, format, tex->images[0]->width(), tex->images[0]->height(), 0,
                                     format, VG_UNSIGNED_BYTE, tex->images[0]->GetBitmap());

                        // delete texture after uploading
                        resource_manager_.DeleteTexture(rid);
                        vgBindTexture(VG_TEXTURE_2D, 0);
                    }
                }
            }
        }

        const Skeleton* skeleton = resource_manager_.GetSkeleton(model.skeleton);
        if (!skeleton) {
            return false;
        }
        object.skeleton = skeleton;
        const Skin* skin = resource_manager_.GetSkin(model.skin);
        if (!skin) {
            return false;
        }
        object.skin = skin;
        for (int i = 0; i < model.materials.size(); i++) {
            object.materials.push_back(resource_manager_.GetMaterial(model.materials[i]));
        }

        // Set program
        VGuint vs = vgCreateShader(VG_VERTEX_SHADER);
        vgShaderSource(vs, PBR_VS);
        vgCompileShader(vs);
        VGuint fs = vgCreateShader(VG_FRAGMENT_SHADER);
        vgShaderSource(fs, PBR_FS);
        vgCompileShader(fs);
        VGuint prog = vgCreateProgram();
        vgAttachShader(prog, vs);
        vgAttachShader(prog, fs);
        vgLinkProgram(prog);
        vgUseProgram(prog);
        program = prog;

        if (vgGetError() != VG_NONE) {
            return false;
        }
        return true;
    }

    bool Renderer::PreUpdate(float delta_time) {
        if (input_states[INPUT_KEY_W]) {
            object.modeling_transform.RotateAxisAngleLocal(Vector3::UNIT_X, delta_time * object.rotate_velocity);
        }
        if (input_states[INPUT_KEY_S]) {
            object.modeling_transform.RotateAxisAngleLocal(Vector3::UNIT_X, -delta_time * object.rotate_velocity);
        }
        if (input_states[INPUT_KEY_A]) {
            object.modeling_transform.RotateAxisAngleLocal(Vector3::UNIT_Y, delta_time * object.rotate_velocity);
        }
        if (input_states[INPUT_KEY_D]) {
            object.modeling_transform.RotateAxisAngleLocal(Vector3::UNIT_Y, -delta_time * object.rotate_velocity);
        }
        if (input_states[INPUT_KEY_UP]) {
            object.modeling_transform.TranslateLocal(-delta_time * object.move_velocity * Vector3::UNIT_Z);
        }
        if (input_states[INPUT_KEY_DOWN]) {
            object.modeling_transform.TranslateLocal(delta_time * object.move_velocity * Vector3::UNIT_Z);
        }
        if (input_states[INPUT_KEY_LEFT]) {
            object.modeling_transform.TranslateLocal(-delta_time * object.move_velocity * Vector3::UNIT_X);
        }
        if (input_states[INPUT_KEY_RIGHT]) {
            object.modeling_transform.TranslateLocal(delta_time * object.move_velocity * Vector3::UNIT_X);
        }
        return true;
    }

    bool Renderer::Render() {
        vgClear(VG_COLOR_BUFFER_BIT | VG_DEPTH_BUFFER_BIT);
        // Prepare PV matrix for bounding volume culling
        Matrix4x4 view_mat = camera.modeling_transform.InverseFast().ToMatrix();
        Matrix4x4 PV_mat = camera.projection.matrix * view_mat;
        Color128 pink = Color128(Color32::PINK);

        // traversal skeleton tree
        const Skeleton* sklt = object.skeleton;
        std::vector<Transform3D> acc_transforms;
        acc_transforms.resize(sklt->GetBoneCount());
        for (uint32_t bi = 0; bi < sklt->GetBoneCount(); bi++) {
            int parent_idx = sklt->GetParentIndex(bi);
            // get accumulated modeling transform
            Transform3D model_t = parent_idx == -1 ? object.modeling_transform * sklt->GetLocalTransform(bi)
                                                   : acc_transforms[parent_idx] * sklt->GetLocalTransform(bi);
            acc_transforms[bi] = model_t;

            // Prepare frustum in local space for bounding volume cullling
            Matrix4x4 PVM_mat = PV_mat * model_t;
            Frustum frustum = Frustum::FromMatrix4x4(PVM_mat);

            // draw submesh bound to bone
            auto& bound_submesh_idx = object.skin->bind_sub_meshes[bi];
            for (int smi = 0; smi < bound_submesh_idx.size(); smi++) {
                const UploadedSubMesh& usm = object.sub_meshes[bound_submesh_idx[smi]];
                // Bounding volume culling
                if (frustum.GetSide(usm.sphere) == math::OUTSIDE) {
                    continue;
                }

                VGuint vao = usm.vao;
                vgBindVertexArray(vao);

                const Material* mat = usm.material;
                VGuint u_model = vgGetUniformLocation(program, "u_model"_vg);
                vgUniformMatrix4fv(u_model, 1, false, (const VGfloat*)model_t.ToMatrix().data);
                VGuint u_view = vgGetUniformLocation(program, "u_view"_vg);
                vgUniformMatrix4fv(u_view, 1, false, (const VGfloat*)view_mat.data);
                VGuint u_projection = vgGetUniformLocation(program, "u_projection"_vg);
                vgUniformMatrix4fv(u_projection, 1, false, (const VGfloat*)camera.projection.matrix.data);

                // unit - texture mapping
                // 0: diffuse, 1: specular, 2: shininess, 3: opacitry, 4: normal, 5: albedo, 6: emission,
                // 7: metallic/roughness, 8:ao

                // bind normal
                vgActiveTexture(VG_TEXTURE4);
                vgBindTexture(VG_TEXTURE_2D, object.texture_rid_to_vgid[mat->textures[TEXTURE_TYPE_NORMAL]]);
                VGuint u_normal = vgGetUniformLocation(program, "u_normal_sampler"_vg);
                vgUniform1i(u_normal, 4);

                // bind albedo
                vgActiveTexture(VG_TEXTURE5);
                vgBindTexture(VG_TEXTURE_2D, object.texture_rid_to_vgid[mat->textures[TEXTURE_TYPE_ALBEDO]]);
                VGuint u_albedo = vgGetUniformLocation(program, "u_albedo_sampler"_vg);
                vgUniform1i(u_albedo, 5);

                // bind metallic/roughness
                vgActiveTexture(VG_TEXTURE7);
                vgBindTexture(VG_TEXTURE_2D,
                              object.texture_rid_to_vgid[mat->textures[TEXTURE_TYPE_METALLIC_ROUGHNESS]]);
                VGuint u_metallic_roughness = vgGetUniformLocation(program, "u_metallic_roughness_sampler"_vg);
                vgUniform1i(u_metallic_roughness, 7);

                // bind emission
                vgActiveTexture(VG_TEXTURE6);
                vgBindTexture(VG_TEXTURE_2D, object.texture_rid_to_vgid[mat->textures[TEXTURE_TYPE_EMISSION]]);
                VGuint u_emission = vgGetUniformLocation(program, "u_emission_sampler"_vg);
                vgUniform1i(u_emission, 6);

                // bind ao
                vgActiveTexture(VG_TEXTURE8);
                vgBindTexture(VG_TEXTURE_2D, object.texture_rid_to_vgid[mat->textures[TEXTURE_TYPE_AMBIENT_OCCLUSION]]);
                VGuint u_ao = vgGetUniformLocation(program, "u_ao_sampler"_vg);
                vgUniform1i(u_ao, 8);

                VGuint u_lightPositions = vgGetUniformLocation(program, "u_lightPositions"_vg);
                Vector3 light_pos[1];
                light_pos[0] = Vector3(10.f, 10.f, 10.f);
                vgUniform3fv(u_lightPositions, 1, (const VGfloat*)(light_pos));

                VGuint u_lightColors = vgGetUniformLocation(program, "u_lightColors"_vg);
                Vector3 light_colors[1];
                light_colors[0] = Vector3(700.f, 700.f, 500.f);
                vgUniform3fv(u_lightColors, 1, (const VGfloat*)(light_colors));

                VGuint u_eyePosition = vgGetUniformLocation(program, "u_eyePosition"_vg);
                vgUniform3f(u_eyePosition, camera.modeling_transform.origin.x, camera.modeling_transform.origin.y,
                            camera.modeling_transform.origin.z);

                vgDrawElements(VG_TRIANGLES, usm.index_count, VG_UNSIGNED_INT, (const void*)0);
            }
        }
        if (vgGetError() != VG_NONE) {
            return false;
        }
        return true;
    }

    bool Renderer::PostUpdate(float delta_time) {
        delta_time;
        return true;
    }

    bool Renderer::Quit() { return true; }

    void Renderer::PressKey(InputKey key) { input_states[key] = true; }
    void Renderer::ReleaseKey(InputKey key) { input_states[key] = false; }
}  // namespace ho




#include "pbr_vs.h"

#include <iostream>

namespace ho {
    void PBR_VS(uint32_t vertex_index, VirtualGPU::Varying& out) {
        Vector3 a_position = FetchAttribute<Vector3>(0, vertex_index);
        Vector3 a_normal = FetchAttribute<Vector3>(1, vertex_index);
        Vector4 a_tangent = FetchAttribute<Vector4>(2, vertex_index);
        Vector2 a_texcoord = FetchAttribute<Vector2>(3, vertex_index);

        Matrix4x4 u_model = FetchUniform<Matrix4x4>("u_model"_vg);
        Matrix4x4 u_view = FetchUniform<Matrix4x4>("u_view"_vg);
        Matrix4x4 u_projection = FetchUniform<Matrix4x4>("u_projection"_vg);

        out.clip_coord = u_projection * u_view * u_model * a_position.ToHomogeneous();
        out.world_pos = (u_model * a_position.ToHomogeneous()).ToCartesian();
        float handedness = a_tangent.w;
        Vector3 tangent = u_model.ToMatrix3x3() * Vector3(a_tangent);
        out.tangent = Vector4(tangent.x, tangent.y, tangent.z, handedness);
        out.normal = u_model.ToMatrix3x3() * a_normal;
        out.uv0 = a_texcoord;
    }
}  // namespace ho




#include "pbr_vs.h"

#include <iostream>

namespace ho {
    void PBR_VS(uint32_t vertex_index, VirtualGPU::Varying& out) {
        Vector3 a_position = FetchAttribute<Vector3>(0, vertex_index);
        Vector3 a_normal = FetchAttribute<Vector3>(1, vertex_index);
        Vector4 a_tangent = FetchAttribute<Vector4>(2, vertex_index);
        Vector2 a_texcoord = FetchAttribute<Vector2>(3, vertex_index);

        Matrix4x4 u_model = FetchUniform<Matrix4x4>("u_model"_vg);
        Matrix4x4 u_view = FetchUniform<Matrix4x4>("u_view"_vg);
        Matrix4x4 u_projection = FetchUniform<Matrix4x4>("u_projection"_vg);

        out.clip_coord = u_projection * u_view * u_model * a_position.ToHomogeneous();
        out.world_pos = (u_model * a_position.ToHomogeneous()).ToCartesian();
        float handedness = a_tangent.w;
        Vector3 tangent = u_model.ToMatrix3x3() * Vector3(a_tangent);
        out.tangent = Vector4(tangent.x, tangent.y, tangent.z, handedness);
        out.normal = u_model.ToMatrix3x3() * a_normal;
        out.uv0 = a_texcoord;
    }
}  // namespace ho